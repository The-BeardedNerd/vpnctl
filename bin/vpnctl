#!/usr/bin/env bash

# VPNCTL - VPN Manager for Linux
# XDG-compliant VPN connection manager with hybrid user/system support
#
# Copyright (c) 2025 VPNCTL Project
# Licensed under the MIT License

set -euo pipefail

# Version and metadata
readonly VPNCTL_VERSION="0.1.0-dev"
readonly VPNCTL_NAME="vpnctl"

# XDG Base Directory Specification
readonly XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
readonly XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
# Fallback for containers where /run/user may not exist
if [[ -n "${XDG_RUNTIME_DIR:-}" ]]; then
    readonly XDG_RUNTIME_DIR="$XDG_RUNTIME_DIR"
else
    # Check if standard runtime dir exists and is writable
    _runtime_candidate="/run/user/$(id -u)"
    if [[ -d "$_runtime_candidate" ]] && [[ -w "$_runtime_candidate" ]]; then
        readonly XDG_RUNTIME_DIR="$_runtime_candidate"
    else
        # Fallback to a writable temp directory
        _runtime_candidate="${TMPDIR:-/tmp}/vpnctl-$(id -u)"
        readonly XDG_RUNTIME_DIR="$_runtime_candidate"
    fi
fi

# Determine installation mode (user vs system)
if [[ $EUID -eq 0 ]]; then
    # System-wide installation
    readonly CONFIG_DIR="/etc/vpnctl"
    readonly PROFILES_DIR="/etc/vpnctl/profiles"
    readonly LOG_DIR="/var/log/vpnctl"
    readonly RUNTIME_DIR="/run/vpnctl"
else
    # User-level installation
    readonly CONFIG_DIR="$XDG_CONFIG_HOME/vpnctl"
    readonly PROFILES_DIR="$XDG_CONFIG_HOME/vpnctl/profiles"
    readonly LOG_DIR="$XDG_STATE_HOME/vpnctl/logs"
    readonly RUNTIME_DIR="$XDG_RUNTIME_DIR/vpnctl"
fi

# Configuration file paths
readonly CONFIG_FILE="$CONFIG_DIR/config.ini"
# PID file for process management
readonly PID_FILE="$RUNTIME_DIR/vpnctl.pid"
readonly STATUS_FILE="$RUNTIME_DIR/vpnctl.status"
readonly LOG_FILE="$LOG_DIR/vpnctl.log"

# Debug mode
readonly DEBUG="${VPNCTL_DEBUG:-0}"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Logging function
log() {
    local level="$1"
    local message="$2"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # Write to log file only if log directory exists (avoid creating during init)
    if [[ -d "$(dirname "$LOG_FILE")" ]]; then
        echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
    fi

    # Output to stderr with colors
    case "$level" in
        "ERROR")
            echo -e "${RED}[ERROR]${NC} $message" >&2
            ;;
        "WARN")
            echo -e "${YELLOW}[WARN]${NC} $message" >&2
            ;;
        "INFO")
            echo -e "${BLUE}[INFO]${NC} $message" >&2
            ;;
        "SUCCESS")
            echo -e "${GREEN}[SUCCESS]${NC} $message" >&2
            ;;
        "DEBUG")
            [[ $DEBUG -eq 1 ]] && echo -e "${BLUE}[DEBUG]${NC} $message" >&2
            ;;
    esac
}

# Error handling
error_exit() {
    log "ERROR" "$1"
    exit 1
}

# Check dependencies
check_dependencies() {
    local required_cmd="${1:-}"
    local missing_deps=()

    # Check for specific command if provided
    if [[ -n "$required_cmd" ]]; then
        if ! command -v "$required_cmd" &> /dev/null; then
            error_exit "Missing required dependency: $required_cmd"
        fi
    else
        # Check for basic commands only
        for cmd in ip; do
            if ! command -v "$cmd" &> /dev/null; then
                missing_deps+=("$cmd")
            fi
        done

        if [[ ${#missing_deps[@]} -gt 0 ]]; then
            error_exit "Missing required dependencies: ${missing_deps[*]}"
        fi
    fi
}

# Initialize directories
init_dirs() {
    local dirs=("$CONFIG_DIR" "$PROFILES_DIR" "$LOG_DIR" "$RUNTIME_DIR")

    for dir in "${dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            # Create directory without logging to avoid circular dependency
            mkdir -p "$dir" || error_exit "Failed to create directory: $dir"
            # Only log after directories exist
            if [[ "$dir" != "$LOG_DIR" ]]; then
                log "INFO" "Created directory: $dir"
            fi
        fi
    done
}

# Show usage information
show_usage() {
    cat << EOF
VPNCTL - VPN Manager for Linux v$VPNCTL_VERSION

USAGE:
    $VPNCTL_NAME <command> [options]

COMMANDS:
    connect <profile>    Connect to VPN profile
    disconnect          Disconnect current VPN
    status              Show connection status
    list                List available profiles
    add <file>          Add VPN profile
    remove <profile>    Remove VPN profile
    fix-dns             Reset DNS configuration
    logs                Show recent logs
    version             Show version information
    help                Show this help message

EXAMPLES:
    $VPNCTL_NAME connect my-server
    $VPNCTL_NAME status
    $VPNCTL_NAME add ~/Downloads/server.ovpn
    $VPNCTL_NAME fix-dns

CONFIGURATION:
    Config: $CONFIG_FILE
    Profiles: $PROFILES_DIR
    Logs: $LOG_FILE

For more information, see the documentation.
EOF
}

# Show version information
show_version() {
    echo "$VPNCTL_NAME version $VPNCTL_VERSION"
    echo "Copyright (c) 2025 VPNCTL Project"
    echo "Licensed under the MIT License"
}

# Connect command (stub)
cmd_connect() {
    local profile="${1:-}"

    if [[ -z "$profile" ]]; then
        error_exit "Profile name required. Use: $VPNCTL_NAME connect <profile>"
    fi

    # Check if already connected
    if [[ -f "$PID_FILE" ]] && kill -0 "$(cat "$PID_FILE")" 2>/dev/null; then
        local current_profile=""
        if [[ -f "$STATUS_FILE" ]]; then
            current_profile=$(grep "profile=" "$STATUS_FILE" | cut -d'=' -f2)
        fi
        error_exit "VPN already connected${current_profile:+ to $current_profile}. Disconnect first with: $VPNCTL_NAME disconnect"
    fi

    # Try both OpenVPN and WireGuard profile formats
    local profile_file=""
    local vpn_type=""

    if [[ -f "$PROFILES_DIR/$profile.ovpn" ]]; then
        profile_file="$PROFILES_DIR/$profile.ovpn"
        vpn_type="openvpn"
    elif [[ -f "$PROFILES_DIR/$profile.conf" ]]; then
        profile_file="$PROFILES_DIR/$profile.conf"
        vpn_type="wireguard"
    else
        error_exit "Profile not found: $profile (searched for $profile.ovpn and $profile.conf in $PROFILES_DIR)"
    fi

    log "INFO" "Connecting to profile: $profile ($vpn_type)"

    # Clean up any stale files
    [[ -f "$PID_FILE" ]] && rm -f "$PID_FILE"
    [[ -f "$STATUS_FILE" ]] && rm -f "$STATUS_FILE"

    # Check specific VPN dependency
    case "$vpn_type" in
        "openvpn")
            check_dependencies "openvpn"
            connect_openvpn "$profile" "$profile_file"
            ;;
        "wireguard")
            check_dependencies "wg-quick"
            connect_wireguard "$profile" "$profile_file"
            ;;
        *)
            error_exit "Unknown VPN type: $vpn_type"
            ;;
    esac
}

# Connect using OpenVPN
connect_openvpn() {
    local profile="$1"
    local profile_file="$2"

    log "INFO" "Starting OpenVPN connection"

    # Determine if we need sudo
    local sudo_cmd=""
    if [[ $EUID -ne 0 ]]; then
        sudo_cmd="sudo"
        log "INFO" "Root privileges required for VPN connection, using sudo"
    fi

    # Start OpenVPN in background
    if $sudo_cmd openvpn --config "$profile_file" --daemon --writepid "$PID_FILE" --log-append "$LOG_DIR/openvpn-$profile.log"; then
        # Wait a moment for process to start
        sleep 2

        # Verify connection started
        if [[ -f "$PID_FILE" ]] && kill -0 "$(cat "$PID_FILE")" 2>/dev/null; then
            local pid
            pid=$(cat "$PID_FILE")

            # Write status file
            cat > "$STATUS_FILE" << EOF
profile=$profile
type=openvpn
pid=$pid
started=$(date '+%Y-%m-%d %H:%M:%S')
config_file=$profile_file
EOF

            log "SUCCESS" "OpenVPN connected successfully (PID: $pid)"
            echo "âœ… Connected to $profile (OpenVPN)"
            echo "ðŸ“„ Logs: $LOG_DIR/openvpn-$profile.log"
            echo "ðŸ” Status: $VPNCTL_NAME status"
        else
            log "ERROR" "OpenVPN failed to start or died immediately"
            error_exit "Failed to establish VPN connection. Check logs: $LOG_DIR/openvpn-$profile.log"
        fi
    else
        log "ERROR" "Failed to start OpenVPN process"
        error_exit "Failed to start OpenVPN. Check that openvpn is installed and profile is valid."
    fi
}

# Connect using WireGuard
connect_wireguard() {
    local profile="$1"
    local profile_file="$2"

    log "INFO" "Starting WireGuard connection"

    # Determine if we need sudo
    local sudo_cmd=""
    if [[ $EUID -ne 0 ]]; then
        sudo_cmd="sudo"
        log "INFO" "Root privileges required for VPN connection, using sudo"
    fi

    # Start WireGuard
    if $sudo_cmd wg-quick up "$profile_file"; then
        # WireGuard doesn't create PID files, so we track it differently
        local wg_interface
        wg_interface=$(basename "$profile_file" .conf)

        # Find the WireGuard process (this is a simplified approach)
        local wg_pid
        wg_pid=$(pgrep -f "wg-quick.*$wg_interface" | head -n1)

        if [[ -n "$wg_pid" ]]; then
            echo "$wg_pid" > "$PID_FILE"
        else
            # Fallback: create a dummy PID since WireGuard runs in kernel space
            echo "$$" > "$PID_FILE"
        fi

        # Write status file
        cat > "$STATUS_FILE" << EOF
profile=$profile
type=wireguard
interface=$wg_interface
started=$(date '+%Y-%m-%d %H:%M:%S')
config_file=$profile_file
EOF

        log "SUCCESS" "WireGuard connected successfully (Interface: $wg_interface)"
        echo "âœ… Connected to $profile (WireGuard)"
        echo "ðŸ”§ Interface: $wg_interface"
        echo "ðŸ” Status: $VPNCTL_NAME status"
    else
        log "ERROR" "Failed to start WireGuard"
        error_exit "Failed to start WireGuard. Check that wireguard-tools is installed and profile is valid."
    fi
}

# Disconnect command
cmd_disconnect() {
    log "INFO" "Disconnecting VPN"

    # Check if there's an active connection
    if [[ ! -f "$PID_FILE" ]]; then
        echo "âŒ No active VPN connection found"
        log "INFO" "No PID file found - no active connection"
        return 0
    fi

    local pid
    pid=$(cat "$PID_FILE" 2>/dev/null)

    if [[ -z "$pid" ]]; then
        echo "âŒ Invalid PID file - cleaning up stale files"
        cleanup_connection_files
        return 0
    fi

    # Get connection info from status file
    local profile=""
    local vpn_type=""
    local interface=""

    if [[ -f "$STATUS_FILE" ]]; then
        profile=$(grep "^profile=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)
        vpn_type=$(grep "^type=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)
        interface=$(grep "^interface=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)
    fi

    # Check if process is actually running
    if ! kill -0 "$pid" 2>/dev/null; then
        echo "âš ï¸  VPN process not running - cleaning up stale files"
        log "WARN" "PID $pid not running - cleaning up stale connection files"
        cleanup_connection_files
        return 0
    fi

    echo "ðŸ”Œ Disconnecting${profile:+ from $profile} (PID: $pid)"
    log "INFO" "Disconnecting VPN connection PID: $pid${profile:+, profile: $profile}"

    # Disconnect based on VPN type
    case "$vpn_type" in
        "openvpn")
            disconnect_openvpn "$pid" "$profile"
            ;;
        "wireguard")
            disconnect_wireguard "$interface" "$profile"
            ;;
        "")
            # Unknown type - try generic process termination
            log "WARN" "Unknown VPN type - attempting generic disconnection"
            disconnect_generic "$pid"
            ;;
        *)
            log "WARN" "Unknown VPN type: $vpn_type - attempting generic disconnection"
            disconnect_generic "$pid"
            ;;
    esac
    # Clean up connection files
    cleanup_connection_files

    echo "âœ… VPN disconnected successfully"
    log "SUCCESS" "VPN disconnection completed"
}

# Disconnect OpenVPN
disconnect_openvpn() {
    local pid="$1"
    local profile="$2"

    log "INFO" "Disconnecting OpenVPN process (PID: $pid)"

    # Determine if we need sudo
    local sudo_cmd=""
    if [[ $EUID -ne 0 ]]; then
        sudo_cmd="sudo"
        log "INFO" "Root privileges required for VPN disconnection, using sudo"
    fi

    # Try graceful termination first (SIGTERM)
    if $sudo_cmd kill -TERM "$pid" 2>/dev/null; then
        log "INFO" "Sent SIGTERM to OpenVPN process, waiting for graceful shutdown"

        # Wait up to 10 seconds for graceful shutdown
        local wait_count=0
        while kill -0 "$pid" 2>/dev/null && [[ $wait_count -lt 10 ]]; do
            sleep 1
            ((wait_count++))
        done

        if kill -0 "$pid" 2>/dev/null; then
            log "WARN" "OpenVPN did not respond to SIGTERM, using SIGKILL"
            $sudo_cmd kill -KILL "$pid" 2>/dev/null
            sleep 2
        fi
    else
        log "WARN" "Could not send SIGTERM to process, trying SIGKILL"
        $sudo_cmd kill -KILL "$pid" 2>/dev/null
    fi

    # Verify process is gone
    if kill -0 "$pid" 2>/dev/null; then
        log "ERROR" "Failed to terminate OpenVPN process"
        error_exit "Failed to disconnect OpenVPN. Process may require manual intervention."
    else
        log "SUCCESS" "OpenVPN process terminated successfully"
    fi
}

# Disconnect WireGuard
disconnect_wireguard() {
    local interface="$1"
    local profile="$2"

    log "INFO" "Disconnecting WireGuard interface: $interface"

    # Determine if we need sudo
    local sudo_cmd=""
    if [[ $EUID -ne 0 ]]; then
        sudo_cmd="sudo"
        log "INFO" "Root privileges required for WireGuard disconnection, using sudo"
    fi

    # Use wg-quick to bring down the interface
    if [[ -n "$interface" ]]; then
        if $sudo_cmd wg-quick down "$interface" 2>/dev/null; then
            log "SUCCESS" "WireGuard interface $interface disconnected successfully"
        else
            log "WARN" "wg-quick down failed, trying alternative method"
            # Fallback: try to remove interface manually
            if $sudo_cmd ip link delete "$interface" 2>/dev/null; then
                log "SUCCESS" "WireGuard interface $interface removed manually"
            else
                log "ERROR" "Failed to disconnect WireGuard interface"
            fi
        fi
    else
        log "WARN" "No interface specified for WireGuard disconnection"
        # Try to find and disconnect any WireGuard interfaces
        local wg_interfaces
        wg_interfaces=$($sudo_cmd wg show interfaces 2>/dev/null || echo "")

        if [[ -n "$wg_interfaces" ]]; then
            for iface in $wg_interfaces; do
                log "INFO" "Found WireGuard interface: $iface, attempting disconnection"
                $sudo_cmd wg-quick down "$iface" 2>/dev/null || true
            done
        fi
    fi
}

# Generic process disconnection for unknown types
disconnect_generic() {
    local pid="$1"

    log "INFO" "Attempting generic process termination (PID: $pid)"

    # Determine if we need sudo (if the process was started with sudo)
    local sudo_cmd=""
    if [[ $EUID -ne 0 ]]; then
        sudo_cmd="sudo"
    fi

    # Try graceful termination first
    if $sudo_cmd kill -TERM "$pid" 2>/dev/null; then
        # Wait up to 5 seconds for graceful shutdown
        local wait_count=0
        while kill -0 "$pid" 2>/dev/null && [[ $wait_count -lt 5 ]]; do
            sleep 1
            ((wait_count++))
        done

        # Force kill if still running
        if kill -0 "$pid" 2>/dev/null; then
            $sudo_cmd kill -KILL "$pid" 2>/dev/null
        fi
    fi

    # Verify process is gone
    if kill -0 "$pid" 2>/dev/null; then
        log "ERROR" "Failed to terminate process $pid"
    else
        log "SUCCESS" "Process $pid terminated successfully"
    fi
}

# Clean up connection tracking files
cleanup_connection_files() {
    if [[ -f "$PID_FILE" ]]; then
        rm -f "$PID_FILE" && log "INFO" "Removed PID file"
    fi

    if [[ -f "$STATUS_FILE" ]]; then
        rm -f "$STATUS_FILE" && log "INFO" "Removed status file"
    fi
}

# Status command (stub)
cmd_status() {
    log "INFO" "Checking VPN status"
    echo "TODO: Implement status check logic"
}

# List profiles command
cmd_list() {
    log "INFO" "Listing available profiles"

    if [[ ! -d "$PROFILES_DIR" ]]; then
        echo "No profiles directory found: $PROFILES_DIR"
        return 1
    fi

    local profiles=("$PROFILES_DIR"/*.{ovpn,conf})
    local found=0

    for profile in "${profiles[@]}"; do
        if [[ -f "$profile" ]]; then
            local basename
            basename=$(basename "$profile")
            local name="${basename%.*}"
            echo "  $name"
            found=1
        fi
    done

    if [[ $found -eq 0 ]]; then
        echo "No VPN profiles found in $PROFILES_DIR"
        echo "Add profiles with: $VPNCTL_NAME add <file>"
    fi
}

# Add profile command (stub)
cmd_add() {
    local file="${1:-}"

    if [[ -z "$file" ]]; then
        error_exit "Profile file required. Use: $VPNCTL_NAME add <file>"
    fi

    if [[ ! -f "$file" ]]; then
        error_exit "Profile file not found: $file"
    fi

    log "INFO" "Adding profile: $file"
    echo "TODO: Implement profile addition logic"
}

# Fix DNS command (stub)
cmd_fix_dns() {
    log "INFO" "Resetting DNS configuration"
    echo "TODO: Implement DNS reset logic"
}

# Show logs command
cmd_logs() {
    if [[ -f "$LOG_FILE" ]] && [[ -s "$LOG_FILE" ]]; then
        tail -n 50 "$LOG_FILE"
    elif [[ -f "$LOG_FILE" ]]; then
        echo "Log file is empty: $LOG_FILE"
    else
        echo "No log file found: $LOG_FILE"
    fi
}

# Main command dispatcher
main() {
    # Initialize
    init_dirs

    # Parse command
    local command="${1:-help}"
    shift || true

    # Check basic dependencies for commands that need network tools
    case "$command" in
        "disconnect"|"status")
            check_dependencies
            ;;
    esac

    case "$command" in
        "connect")
            cmd_connect "$@"
            ;;
        "disconnect")
            cmd_disconnect "$@"
            ;;
        "status")
            cmd_status "$@"
            ;;
        "list")
            cmd_list "$@"
            ;;
        "add")
            cmd_add "$@"
            ;;
        "remove")
            echo "TODO: Implement remove command"
            ;;
        "fix-dns")
            cmd_fix_dns "$@"
            ;;
        "logs")
            cmd_logs "$@"
            ;;
        "version")
            show_version
            ;;
        "help"|"-h"|"--help")
            show_usage
            ;;
        *)
            error_exit "Unknown command: $command. Use '$VPNCTL_NAME help' for usage."
            ;;
    esac
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
