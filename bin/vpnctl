#!/usr/bin/env bash

# VPNCTL - VPN Manager for Linux
# XDG-compliant VPN connection manager with hybrid user/system support
#
# Copyright (c) 2025 VPNCTL Project
# Licensed under the MIT License

set -euo pipefail

# Version and metadata
readonly VPNCTL_VERSION="0.1.0-dev"
readonly VPNCTL_NAME="vpnctl"

# XDG Base Directory Specification
readonly XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
readonly XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
# Fallback for containers where /run/user may not exist
if [[ -n "${XDG_RUNTIME_DIR:-}" ]]; then
	readonly XDG_RUNTIME_DIR="$XDG_RUNTIME_DIR"
else
	# Check if standard runtime dir exists and is writable
	_runtime_candidate="/run/user/$(id -u)"
	if [[ -d "$_runtime_candidate" ]] && [[ -w "$_runtime_candidate" ]]; then
		readonly XDG_RUNTIME_DIR="$_runtime_candidate"
	else
		# Fallback to a writable temp directory
		_runtime_candidate="${TMPDIR:-/tmp}/vpnctl-$(id -u)"
		readonly XDG_RUNTIME_DIR="$_runtime_candidate"
	fi
fi

# Determine installation mode (user vs system)
if [[ $EUID -eq 0 ]]; then
	# System-wide installation
	readonly CONFIG_DIR="/etc/vpnctl"
	readonly PROFILES_DIR="/etc/vpnctl/profiles"
	readonly LOG_DIR="/var/log/vpnctl"
	readonly RUNTIME_DIR="/run/vpnctl"
else
	# User-level installation
	readonly CONFIG_DIR="$XDG_CONFIG_HOME/vpnctl"
	readonly PROFILES_DIR="$XDG_CONFIG_HOME/vpnctl/profiles"
	readonly LOG_DIR="$XDG_STATE_HOME/vpnctl/logs"
	readonly RUNTIME_DIR="$XDG_RUNTIME_DIR/vpnctl"
fi

# Configuration file paths
readonly CONFIG_FILE="$CONFIG_DIR/config.ini"
# PID file for process management
readonly PID_FILE="$RUNTIME_DIR/vpnctl.pid"
readonly STATUS_FILE="$RUNTIME_DIR/vpnctl.status"
readonly LOG_FILE="$LOG_DIR/vpnctl.log"

# Debug mode
readonly DEBUG="${VPNCTL_DEBUG:-0}"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Logging function
log() {
	local level="$1"
	local message="$2"
	local timestamp
	timestamp=$(date '+%Y-%m-%d %H:%M:%S')

	# Write to log file only if log directory exists (avoid creating during init)
	if [[ -d "$(dirname "$LOG_FILE")" ]]; then
		echo "[$timestamp] [$level] $message" >>"$LOG_FILE"
	fi

	# Output to stderr with colors
	case "$level" in
	"ERROR")
		echo -e "${RED}[ERROR]${NC} $message" >&2
		;;
	"WARN")
		echo -e "${YELLOW}[WARN]${NC} $message" >&2
		;;
	"INFO")
		echo -e "${BLUE}[INFO]${NC} $message" >&2
		;;
	"SUCCESS")
		echo -e "${GREEN}[SUCCESS]${NC} $message" >&2
		;;
	"DEBUG")
		[[ $DEBUG -eq 1 ]] && echo -e "${BLUE}[DEBUG]${NC} $message" >&2
		;;
	esac
}

# Error handling
error_exit() {
	log "ERROR" "$1"
	exit 1
}

# Check dependencies
check_dependencies() {
	local required_cmd="${1:-}"

	# Check for specific command if provided
	if [[ -n "$required_cmd" ]]; then
		if ! command -v "$required_cmd" &>/dev/null; then
			error_exit "Missing required dependency: $required_cmd"
		fi
	else
		# Check for basic commands only
		if ! command -v "ip" &>/dev/null; then
			error_exit "Missing required dependency: ip"
		fi
	fi
}

# Initialize directories
init_dirs() {
	local dirs=("$CONFIG_DIR" "$PROFILES_DIR" "$LOG_DIR" "$RUNTIME_DIR")

	for dir in "${dirs[@]}"; do
		if [[ ! -d "$dir" ]]; then
			# Create directory without logging to avoid circular dependency
			mkdir -p "$dir" || error_exit "Failed to create directory: $dir"
			# Only log after directories exist
			if [[ "$dir" != "$LOG_DIR" ]]; then
				log "INFO" "Created directory: $dir"
			fi
		fi
	done
}

# Show usage information
show_usage() {
	cat <<EOF
VPNCTL - VPN Manager for Linux v$VPNCTL_VERSION

USAGE:
    $VPNCTL_NAME <command> [options]

COMMANDS:
    connect <profile>    Connect to VPN profile
    disconnect          Disconnect current VPN
    status              Show connection status
    list                List available profiles
    add <file>          Add VPN profile
    remove <profile>    Remove VPN profile
    fix-dns             Reset DNS configuration
    logs                Show recent logs
    version             Show version information
    help                Show this help message

EXAMPLES:
    $VPNCTL_NAME connect my-server
    $VPNCTL_NAME status
    $VPNCTL_NAME add ~/Downloads/server.ovpn
    $VPNCTL_NAME fix-dns

CONFIGURATION:
    Config: $CONFIG_FILE
    Profiles: $PROFILES_DIR
    Logs: $LOG_FILE

For more information, see the documentation.
EOF
}

# Show version information
show_version() {
	echo "$VPNCTL_NAME version $VPNCTL_VERSION"
	echo "Copyright (c) 2025 VPNCTL Project"
	echo "Licensed under the MIT License"
}

# Connect command (stub)
cmd_connect() {
	local profile="${1:-}"

	if [[ -z "$profile" ]]; then
		error_exit "Profile name required. Use: $VPNCTL_NAME connect <profile>"
	fi

	# Check if already connected
	if [[ -f "$PID_FILE" ]] && kill -0 "$(cat "$PID_FILE")" 2>/dev/null; then
		local current_profile=""
		if [[ -f "$STATUS_FILE" ]]; then
			current_profile=$(grep "profile=" "$STATUS_FILE" | cut -d'=' -f2)
		fi
		error_exit "VPN already connected${current_profile:+ to $current_profile}. Disconnect first with: $VPNCTL_NAME disconnect"
	fi

	# Try both OpenVPN and WireGuard profile formats
	local profile_file=""
	local vpn_type=""

	if [[ -f "$PROFILES_DIR/$profile.ovpn" ]]; then
		profile_file="$PROFILES_DIR/$profile.ovpn"
		vpn_type="openvpn"
	elif [[ -f "$PROFILES_DIR/$profile.conf" ]]; then
		profile_file="$PROFILES_DIR/$profile.conf"
		vpn_type="wireguard"
	else
		error_exit "Profile not found: $profile (searched for $profile.ovpn and $profile.conf in $PROFILES_DIR)"
	fi

	log "INFO" "Connecting to profile: $profile ($vpn_type)"

	# Clean up any stale files
	[[ -f "$PID_FILE" ]] && rm -f "$PID_FILE"
	[[ -f "$STATUS_FILE" ]] && rm -f "$STATUS_FILE"

	# Check specific VPN dependency
	case "$vpn_type" in
	"openvpn")
		check_dependencies "openvpn"
		connect_openvpn "$profile" "$profile_file"
		;;
	"wireguard")
		check_dependencies "wg-quick"
		connect_wireguard "$profile" "$profile_file"
		;;
	*)
		error_exit "Unknown VPN type: $vpn_type"
		;;
	esac
}

# Connect using OpenVPN
connect_openvpn() {
	local profile="$1"
	local profile_file="$2"

	log "INFO" "Starting OpenVPN connection"

	# Determine if we need sudo
	local sudo_cmd=""
	if [[ $EUID -ne 0 ]]; then
		sudo_cmd="sudo"
		log "INFO" "Root privileges required for VPN connection, using sudo"
	fi

	# Start OpenVPN in background
	if $sudo_cmd openvpn --config "$profile_file" --daemon --writepid "$PID_FILE" --log-append "$LOG_DIR/openvpn-$profile.log"; then
		# Wait a moment for process to start
		sleep 2

		# Verify connection started
		if [[ -f "$PID_FILE" ]] && kill -0 "$(cat "$PID_FILE")" 2>/dev/null; then
			local pid
			pid=$(cat "$PID_FILE")

			# Write status file
			cat >"$STATUS_FILE" <<EOF
profile=$profile
type=openvpn
pid=$pid
started=$(date '+%Y-%m-%d %H:%M:%S')
config_file=$profile_file
EOF

			log "SUCCESS" "OpenVPN connected successfully (PID: $pid)"
			echo "âœ… Connected to $profile (OpenVPN)"
			echo "ðŸ“„ Logs: $LOG_DIR/openvpn-$profile.log"
			echo "ðŸ” Status: $VPNCTL_NAME status"
		else
			log "ERROR" "OpenVPN failed to start or died immediately"
			error_exit "Failed to establish VPN connection. Check logs: $LOG_DIR/openvpn-$profile.log"
		fi
	else
		log "ERROR" "Failed to start OpenVPN process"
		error_exit "Failed to start OpenVPN. Check that openvpn is installed and profile is valid."
	fi
}

# Connect using WireGuard
connect_wireguard() {
	local profile="$1"
	local profile_file="$2"

	log "INFO" "Starting WireGuard connection"

	# Determine if we need sudo
	local sudo_cmd=""
	if [[ $EUID -ne 0 ]]; then
		sudo_cmd="sudo"
		log "INFO" "Root privileges required for VPN connection, using sudo"
	fi

	# Start WireGuard
	if $sudo_cmd wg-quick up "$profile_file"; then
		# WireGuard doesn't create PID files, so we track it differently
		local wg_interface
		wg_interface=$(basename "$profile_file" .conf)

		# Find the WireGuard process (this is a simplified approach)
		local wg_pid
		wg_pid=$(pgrep -f "wg-quick.*$wg_interface" | head -n1)

		if [[ -n "$wg_pid" ]]; then
			echo "$wg_pid" >"$PID_FILE"
		else
			# Fallback: create a dummy PID since WireGuard runs in kernel space
			echo "$$" >"$PID_FILE"
		fi

		# Write status file
		cat >"$STATUS_FILE" <<EOF
profile=$profile
type=wireguard
interface=$wg_interface
started=$(date '+%Y-%m-%d %H:%M:%S')
config_file=$profile_file
EOF

		log "SUCCESS" "WireGuard connected successfully (Interface: $wg_interface)"
		echo "âœ… Connected to $profile (WireGuard)"
		echo "ðŸ”§ Interface: $wg_interface"
		echo "ðŸ” Status: $VPNCTL_NAME status"
	else
		log "ERROR" "Failed to start WireGuard"
		error_exit "Failed to start WireGuard. Check that wireguard-tools is installed and profile is valid."
	fi
}

# Disconnect command
cmd_disconnect() {
	log "INFO" "Disconnecting VPN"

	# Check if there's an active connection
	if [[ ! -f "$PID_FILE" ]]; then
		echo "âŒ No active VPN connection found"
		log "INFO" "No PID file found - no active connection"
		return 0
	fi

	local pid
	pid=$(cat "$PID_FILE" 2>/dev/null)

	if [[ -z "$pid" ]]; then
		echo "âŒ Invalid PID file - cleaning up stale files"
		cleanup_connection_files
		return 0
	fi

	# Get connection info from status file
	local profile=""
	local vpn_type=""
	local interface=""

	if [[ -f "$STATUS_FILE" ]]; then
		profile=$(grep "^profile=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)
		vpn_type=$(grep "^type=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)
		interface=$(grep "^interface=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)
	fi

	# Check if process is actually running
	if ! kill -0 "$pid" 2>/dev/null; then
		echo "âš ï¸  VPN process not running - cleaning up stale files"
		log "WARN" "PID $pid not running - cleaning up stale connection files"
		cleanup_connection_files
		return 0
	fi

	echo "ðŸ”Œ Disconnecting${profile:+ from $profile} (PID: $pid)"
	log "INFO" "Disconnecting VPN connection PID: $pid${profile:+, profile: $profile}"

	# Disconnect based on VPN type
	case "$vpn_type" in
	"openvpn")
		disconnect_openvpn "$pid" "$profile"
		;;
	"wireguard")
		disconnect_wireguard "$interface" "$profile"
		;;
	"")
		# Unknown type - try generic process termination
		log "WARN" "Unknown VPN type - attempting generic disconnection"
		disconnect_generic "$pid"
		;;
	*)
		log "WARN" "Unknown VPN type: $vpn_type - attempting generic disconnection"
		disconnect_generic "$pid"
		;;
	esac
	# Clean up connection files
	cleanup_connection_files

	echo "âœ… VPN disconnected successfully"
	log "SUCCESS" "VPN disconnection completed"
}

# Disconnect OpenVPN
disconnect_openvpn() {
	local pid="$1"
	local profile="$2"

	log "INFO" "Disconnecting OpenVPN process (PID: $pid)"

	# Determine if we need sudo
	local sudo_cmd=""
	if [[ $EUID -ne 0 ]]; then
		sudo_cmd="sudo"
		log "INFO" "Root privileges required for VPN disconnection, using sudo"
	fi

	# Try graceful termination first (SIGTERM)
	if $sudo_cmd kill -TERM "$pid" 2>/dev/null; then
		log "INFO" "Sent SIGTERM to OpenVPN process, waiting for graceful shutdown"

		# Wait up to 10 seconds for graceful shutdown
		local wait_count=0
		while kill -0 "$pid" 2>/dev/null && [[ $wait_count -lt 10 ]]; do
			sleep 1
			((wait_count++))
		done

		if kill -0 "$pid" 2>/dev/null; then
			log "WARN" "OpenVPN did not respond to SIGTERM, using SIGKILL"
			$sudo_cmd kill -KILL "$pid" 2>/dev/null
			sleep 2
		fi
	else
		log "WARN" "Could not send SIGTERM to process, trying SIGKILL"
		$sudo_cmd kill -KILL "$pid" 2>/dev/null
	fi

	# Verify process is gone
	if kill -0 "$pid" 2>/dev/null; then
		log "ERROR" "Failed to terminate OpenVPN process"
		error_exit "Failed to disconnect OpenVPN. Process may require manual intervention."
	else
		log "SUCCESS" "OpenVPN process terminated successfully"
	fi
}

# Disconnect WireGuard
disconnect_wireguard() {
	local interface="$1"
	local profile="$2"

	log "INFO" "Disconnecting WireGuard interface: $interface"

	# Determine if we need sudo
	local sudo_cmd=""
	if [[ $EUID -ne 0 ]]; then
		sudo_cmd="sudo"
		log "INFO" "Root privileges required for WireGuard disconnection, using sudo"
	fi

	# Use wg-quick to bring down the interface
	if [[ -n "$interface" ]]; then
		if $sudo_cmd wg-quick down "$interface" 2>/dev/null; then
			log "SUCCESS" "WireGuard interface $interface disconnected successfully"
		else
			log "WARN" "wg-quick down failed, trying alternative method"
			# Fallback: try to remove interface manually
			if $sudo_cmd ip link delete "$interface" 2>/dev/null; then
				log "SUCCESS" "WireGuard interface $interface removed manually"
			else
				log "ERROR" "Failed to disconnect WireGuard interface"
			fi
		fi
	else
		log "WARN" "No interface specified for WireGuard disconnection"
		# Try to find and disconnect any WireGuard interfaces
		local wg_interfaces
		wg_interfaces=$($sudo_cmd wg show interfaces 2>/dev/null || echo "")

		if [[ -n "$wg_interfaces" ]]; then
			for iface in $wg_interfaces; do
				log "INFO" "Found WireGuard interface: $iface, attempting disconnection"
				$sudo_cmd wg-quick down "$iface" 2>/dev/null || true
			done
		fi
	fi
}

# Generic process disconnection for unknown types
disconnect_generic() {
	local pid="$1"

	log "INFO" "Attempting generic process termination (PID: $pid)"

	# Determine if we need sudo (if the process was started with sudo)
	local sudo_cmd=""
	if [[ $EUID -ne 0 ]]; then
		sudo_cmd="sudo"
	fi

	# Try graceful termination first
	if $sudo_cmd kill -TERM "$pid" 2>/dev/null; then
		# Wait up to 5 seconds for graceful shutdown
		local wait_count=0
		while kill -0 "$pid" 2>/dev/null && [[ $wait_count -lt 5 ]]; do
			sleep 1
			((wait_count++))
		done

		# Force kill if still running
		if kill -0 "$pid" 2>/dev/null; then
			$sudo_cmd kill -KILL "$pid" 2>/dev/null
		fi
	fi

	# Verify process is gone
	if kill -0 "$pid" 2>/dev/null; then
		log "ERROR" "Failed to terminate process $pid"
	else
		log "SUCCESS" "Process $pid terminated successfully"
	fi
}

# Clean up connection tracking files
cleanup_connection_files() {
	if [[ -f "$PID_FILE" ]]; then
		rm -f "$PID_FILE" && log "INFO" "Removed PID file"
	fi

	if [[ -f "$STATUS_FILE" ]]; then
		rm -f "$STATUS_FILE" && log "INFO" "Removed status file"
	fi
}

# Status command (stub)
cmd_status() {
	log "INFO" "Checking VPN status"

	# Check if there's an active connection
	if [[ ! -f "$PID_FILE" ]] || [[ ! -f "$STATUS_FILE" ]]; then
		echo "ðŸ”´ VPN Status: Disconnected"
		echo "   No active VPN connection"
		echo ""
		echo "ðŸ’¡ To connect: $VPNCTL_NAME connect <profile>"
		echo "ðŸ“‹ Available profiles: $VPNCTL_NAME list"
		return 0
	fi

	# Read PID and validate process
	local pid
	pid=$(cat "$PID_FILE" 2>/dev/null)

	if [[ -z "$pid" ]] || ! kill -0 "$pid" 2>/dev/null; then
		echo "âš ï¸  VPN Status: Connection Lost"
		echo "   Process is no longer running (PID: ${pid:-unknown})"
		echo "   Cleaning up stale connection files..."
		cleanup_connection_files
		return 0
	fi

	# Parse status file
	local profile vpn_type started config_file interface
	profile=$(grep "^profile=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)
	vpn_type=$(grep "^type=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)
	started=$(grep "^started=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)
	config_file=$(grep "^config_file=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)
	interface=$(grep "^interface=" "$STATUS_FILE" 2>/dev/null | cut -d'=' -f2)

	# Calculate connection duration
	local duration=""
	if [[ -n "$started" ]]; then
		local start_epoch current_epoch duration_seconds
		start_epoch=$(date -d "$started" +%s 2>/dev/null || echo "0")
		current_epoch=$(date +%s)
		duration_seconds=$((current_epoch - start_epoch))

		if [[ $duration_seconds -gt 0 ]]; then
			local hours minutes seconds
			hours=$((duration_seconds / 3600))
			minutes=$(((duration_seconds % 3600) / 60))
			seconds=$((duration_seconds % 60))
			duration=$(printf "%02d:%02d:%02d" "$hours" "$minutes" "$seconds")
		fi
	fi

	# Display main status
	echo "ðŸŸ¢ VPN Status: Connected"
	echo "   Profile: ${profile:-Unknown}"
	echo "   Type: $(echo "${vpn_type:-Unknown}" | tr '[:lower:]' '[:upper:]')"
	echo "   PID: $pid"
	[[ -n "$duration" ]] && echo "   Duration: $duration"
	[[ -n "$started" ]] && echo "   Started: $started"

	# Show network information based on VPN type
	case "$vpn_type" in
	"openvpn")
		show_openvpn_status "$interface"
		;;
	"wireguard")
		show_wireguard_status "$interface"
		;;
	*)
		echo "   Interface: ${interface:-Unknown}"
		;;
	esac

	# Show configuration file
	[[ -n "$config_file" ]] && echo "   Config: $config_file"

	# Show log information
	case "$vpn_type" in
	"openvpn")
		local log_file="$LOG_DIR/openvpn-$profile.log"
		[[ -f "$log_file" ]] && echo "   Logs: $log_file"
		;;
	"wireguard")
		echo "   Logs: Use 'journalctl -u wg-quick@${interface:-wg0}' or 'dmesg | grep wireguard'"
		;;
	esac

	echo ""
	echo "ðŸ’¡ To disconnect: $VPNCTL_NAME disconnect"
	echo "ðŸ“Š To view logs: $VPNCTL_NAME logs"
}

# Show OpenVPN specific status information
show_openvpn_status() {
	local interface="${1:-tun0}"

	# Try to detect the actual interface
	local actual_interface
	actual_interface=$(ip link show | grep -E "tun[0-9]+|tap[0-9]+" | head -n1 | cut -d: -f2 | tr -d ' ')

	if [[ -n "$actual_interface" ]]; then
		interface="$actual_interface"
		echo "   Interface: $interface"

		# Get IP address
		local vpn_ip
		vpn_ip=$(ip addr show "$interface" 2>/dev/null | grep "inet " | awk '{print $2}' | cut -d'/' -f1)
		[[ -n "$vpn_ip" ]] && echo "   VPN IP: $vpn_ip"

		# Get interface statistics
		local stats
		stats=$(ip -s link show "$interface" 2>/dev/null | tail -n 2)
		if [[ -n "$stats" ]]; then
			local rx_bytes tx_bytes
			rx_bytes=$(echo "$stats" | head -n1 | awk '{print $1}')
			tx_bytes=$(echo "$stats" | head -n1 | awk '{print $9}')

			if [[ -n "$rx_bytes" ]] && [[ -n "$tx_bytes" ]]; then
				echo "   Traffic: RX $(format_bytes "$rx_bytes") / TX $(format_bytes "$tx_bytes")"
			fi
		fi
	else
		echo "   Interface: Not detected (may be initializing)"
	fi
}

# Show WireGuard specific status information
show_wireguard_status() {
	local interface="${1:-wg0}"

	if command -v wg &>/dev/null && [[ -n "$interface" ]]; then
		echo "   Interface: $interface"

		# Get WireGuard status
		local wg_status
		wg_status=$(sudo wg show "$interface" 2>/dev/null)

		if [[ -n "$wg_status" ]]; then
			# Extract peer information
			local peer_count
			peer_count=$(echo "$wg_status" | grep -c "peer:")
			[[ $peer_count -gt 0 ]] && echo "   Peers: $peer_count"

			# Get endpoint if available
			local endpoint
			endpoint=$(echo "$wg_status" | grep "endpoint:" | head -n1 | cut -d' ' -f2)
			[[ -n "$endpoint" ]] && echo "   Endpoint: $endpoint"

			# Get transfer statistics
			local transfer
			transfer=$(echo "$wg_status" | grep "transfer:" | head -n1 | cut -d' ' -f2-)
			[[ -n "$transfer" ]] && echo "   Transfer: $transfer"
		fi

		# Get IP address from interface
		local vpn_ip
		vpn_ip=$(ip addr show "$interface" 2>/dev/null | grep "inet " | awk '{print $2}' | cut -d'/' -f1)
		[[ -n "$vpn_ip" ]] && echo "   VPN IP: $vpn_ip"
	else
		echo "   Interface: $interface (WireGuard tools not available for detailed status)"
	fi
}

# Format bytes in human readable format
format_bytes() {
	local bytes="$1"

	if [[ -z "$bytes" ]] || [[ ! "$bytes" =~ ^[0-9]+$ ]]; then
		echo "N/A"
		return
	fi

	if [[ $bytes -ge 1073741824 ]]; then
		awk "BEGIN {printf \"%.1f GB\", $bytes/1073741824}"
	elif [[ $bytes -ge 1048576 ]]; then
		awk "BEGIN {printf \"%.1f MB\", $bytes/1048576}"
	elif [[ $bytes -ge 1024 ]]; then
		awk "BEGIN {printf \"%.1f KB\", $bytes/1024}"
	else
		echo "${bytes} B"
	fi
}

# List profiles command
cmd_list() {
	log "INFO" "Listing available profiles"

	if [[ ! -d "$PROFILES_DIR" ]]; then
		echo "No profiles directory found: $PROFILES_DIR"
		return 1
	fi

	local profiles=("$PROFILES_DIR"/*.{ovpn,conf})
	local found=0

	for profile in "${profiles[@]}"; do
		if [[ -f "$profile" ]]; then
			local basename
			basename=$(basename "$profile")
			local name="${basename%.*}"
			echo "  $name"
			found=1
		fi
	done

	if [[ $found -eq 0 ]]; then
		echo "No VPN profiles found in $PROFILES_DIR"
		echo "Add profiles with: $VPNCTL_NAME add <file>"
	fi
}

# Add profile command (stub)
cmd_add() {
	local file="${1:-}"

	if [[ -z "$file" ]]; then
		error_exit "Profile file required. Use: $VPNCTL_NAME add <file>"
	fi

	if [[ ! -f "$file" ]]; then
		error_exit "Profile file not found: $file"
	fi

	log "INFO" "Adding profile: $file"
	echo "TODO: Implement profile addition logic"
}

# Fix DNS command (stub)
cmd_fix_dns() {
	log "INFO" "Resetting DNS configuration"
	echo "TODO: Implement DNS reset logic"
}

# Show logs command
cmd_logs() {
	if [[ -f "$LOG_FILE" ]] && [[ -s "$LOG_FILE" ]]; then
		tail -n 50 "$LOG_FILE"
	elif [[ -f "$LOG_FILE" ]]; then
		echo "Log file is empty: $LOG_FILE"
	else
		echo "No log file found: $LOG_FILE"
	fi
}

# Main command dispatcher
main() {
	# Initialize
	init_dirs

	# Parse command
	local command="${1:-help}"
	shift || true

	# Check basic dependencies for commands that need network tools
	case "$command" in
	"disconnect" | "status")
		check_dependencies
		;;
	esac

	case "$command" in
	"connect")
		cmd_connect "$@"
		;;
	"disconnect")
		cmd_disconnect "$@"
		;;
	"status")
		cmd_status "$@"
		;;
	"list")
		cmd_list "$@"
		;;
	"add")
		cmd_add "$@"
		;;
	"remove")
		echo "TODO: Implement remove command"
		;;
	"fix-dns")
		cmd_fix_dns "$@"
		;;
	"logs")
		cmd_logs "$@"
		;;
	"version")
		show_version
		;;
	"help" | "-h" | "--help")
		show_usage
		;;
	*)
		error_exit "Unknown command: $command. Use '$VPNCTL_NAME help' for usage."
		;;
	esac
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	main "$@"
fi
